<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Car Sales Dashboard</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/topojson/3.0.2/topojson.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #eabc66 0%, #764ba2 100%);
            min-height: 100vh;
            margin: 0;
            position: relative;
            overflow-x: hidden;
        }

        .filter-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 240px;
            height: 100vh;
            background-color: #2c3e50;
            color: white;
            z-index: 10;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            overflow-y: auto;
            overflow-x: hidden;
            box-sizing: border-box;
            padding: 20px;
            border-top-right-radius: 10px;
            border-bottom-right-radius: 10px;
        }

        .dashboard-container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
            margin-top: 20px;
        }

        .dashboard-header {
            text-align: center;
            margin-bottom: 30px;
        }

        .dashboard-title {
            font-size: 2.5em;
            color: #2c3e50;
            margin-bottom: 10px;
            font-weight: 700;
        }

        .kpi-cards {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        .kpi-card {
            background: linear-gradient(135deg, #4ecdc4, #0b5b4b);
            color: white;
            padding: 25px;
            border-radius: 15px;
            text-align: center;
            min-width: 200px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.1);
            transition: transform 0.3s ease;
        }

        .kpi-card:nth-child(2) {
            background: linear-gradient(135deg, #4ecdc4, #0b5b4b);
        }

        .kpi-card:nth-child(3) {
            background: linear-gradient(135deg, #4ecdc4, #0b5b4b);
        }

        .kpi-card:hover {
            transform: translateY(-5px);
        }

        .kpi-value {
            font-size: 2.2em;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .kpi-label {
            font-size: 0.9em;
            opacity: 0.9;
        }

        .filters-container {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        .filter-group {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .filter-label {
            font-weight: 600;
            margin-bottom: 8px;
            color: #2c3e50;
        }

        select {
            padding: 10px 15px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 14px;
            background: white;
            transition: border-color 0.3s ease;
        }

        select:focus {
            outline: none;
            border-color: #667eea;
        }

        .company-logos {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        .company-logo {
            padding: 10px 20px;
            background: #f8f9fa;
            border: 2px solid #dee2e6;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
            color: #495057;
        }

        .company-logo:hover,
        .company-logo.active {
            background: #667eea;
            color: white;
            border-color: #667eea;
            transform: scale(1.05);
        }

        .charts-grid {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }

        .chart-container {
            background: white;
            border-radius: 15px;
            padding: 15px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.08);
            border: 1px solid #e9ecef;
        }

        #pie-chart {
            display: flex;
            justify-content: center;
        }

        .chart-title {
            font-size: 1.3em;
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 20px;
            text-align: center;
        }

        .full-width {
            grid-column: 1 / -1;
        }

        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 12px 16px;
            border-radius: 8px;
            font-size: 13px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .axis text {
            font-size: 12px;
            fill: #666;
        }

        .axis path,
        .axis line {
            fill: none;
            stroke: #ddd;
            shape-rendering: crispEdges;
        }

        .line {
            fill: none;
            stroke: #64b5f6;
            stroke-width: 3;
        }

        .dot {
            fill: #64b5f6;
            stroke: white;
            stroke-width: 2;
        }

        .dot:hover {
            r: 6;
            fill: #b62727;
        }

        .bar:hover {
            opacity: 0.8;
        }

        .arc:hover {
            opacity: 0.8;
        }

        .layout {
            display: flex;
            min-height: 100vh;
        }

        #company-filters {
            max-height: 200px;
            overflow-y: auto;
            padding-right: 5px;
        }

        #company-filters::-webkit-scrollbar {
            width: 6px;
        }

        #company-filters::-webkit-scrollbar-thumb {
            background-color: #888;
            border-radius: 4px;
        }

        #company-filters::-webkit-scrollbar-thumb:hover {
            background-color: #555;
        }

        #reset-filters {
            width: 100%;
            padding: 10px;
            background-color: #667eea;
            border: none;
            color: white;
            border-radius: 8px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.1s ease-in-out;
            transform: scale(1);
        }

        #reset-filters:hover {
            transform: scale(1.03);
            background-color: #5a67d8;
        }

        #reset-filters:active {
            transform: scale(0.96);
            background-color: #4c51bf;
        }


        .sidebar {
            width: 240px;
            padding: 20px;
            background-color: #2c3e50;
            color: white;
            overflow-y: auto;
        }

        .sidebar h3 {
            margin-top: 20px;
            font-size: 16px;
            border-bottom: 1px solid white;
        }

        .sidebar label,
        .sidebar select {
            display: block;
            margin: 5px 0;
        }

        .sidebar select {
            width: 100%;
            padding: 6px;
            border-radius: 4px;
            border: none;
        }

        .toggle-btn {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 20;
            background-color: #2c3e50;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .toggle-btn:hover {
            transform: scale(1.1);
        }

        .filter-overlay.hidden {
            transform: translateX(-100%);
            transition: transform 0.3s ease;
        }

        .filter-overlay {
            transition: transform 0.3s ease;
        }

        .main {
            position: relative;
            z-index: 1;
            width: 100vw;
            min-height: 100vh;
            padding-left: 0;
        }

        @media (max-width: 768px) {
            .charts-grid {
                grid-template-columns: 1fr;
            }

            .kpi-cards {
                flex-direction: column;
                align-items: center;
            }

            .filters-container {
                flex-direction: column;
                align-items: center;
            }
        }
    </style>
</head>

<body>
    <button id="toggleSidebar" class="toggle-btn">â˜°</button>
    <!-- Sidebar -->
    <div class="layout">
        <div class="filter-overlay ">
            <div class="sidebar">
                <h2>Filters</h2>
                <h3>Year</h3>
                <select id="year-filter">
                    <option value="all">All Years</option>
                </select>

                <h3>Gender</h3>
                <select id="gender-filter">
                    <option value="all">All Genders</option>
                    <option value="Male">Male</option>
                    <option value="Female">Female</option>
                </select>

                <h3>Transmission</h3>
                <select id="transmission-filter">
                    <option value="all">All Types</option>
                    <option value="Auto">Automatic</option>
                    <option value="Manual">Manual</option>
                </select>

                <h3>Company</h3>
                <div id="company-filters" style="max-height: 200px; overflow-y: auto; padding-right: 5px;"></div>
                <div style="margin-top: 20px;">
                    <button id="reset-filters"
                        style="width: 100%; padding: 10px; background-color: #667eea; border: none; color: white; border-radius: 8px;">Reset
                        Filters</button>
                </div>
            </div>
        </div>

        <div class="main">
            <div class="dashboard-container">
                <div class="dashboard-header">
                    <h1 class="dashboard-title">ðŸš— Car Sales Analysis Dashboard</h1>
                </div>

                <!-- KPI Cards -->
                <div class="kpi-cards">
                    <div class="kpi-card">
                        <div class="kpi-value" id="total-cars">0</div>
                        <div class="kpi-label">Total Cars Sold</div>
                    </div>
                    <div class="kpi-card">
                        <div class="kpi-value" id="avg-price">$0</div>
                        <div class="kpi-label">Average Price</div>
                    </div>
                    <div class="kpi-card">
                        <div class="kpi-value" id="total-revenue">$0</div>
                        <div class="kpi-label">Total Revenue</div>
                    </div>
                    <div class="kpi-card">
                        <div class="kpi-value" id="avg-customer-income">$0</div>
                        <div class="kpi-label">Average Customer Income</div>
                    </div>
                </div>


                <!-- First Row: 3 charts -->
                <div class="charts-grid" style="grid-template-columns: 1fr 1fr 1fr;">
                    <div class="chart-container">
                        <h3 class="chart-title"> Sales Over Time</h3>
                        <div id="time-series-chart"></div>
                    </div>
                    <div class="chart-container">
                        <h3 class="chart-title"> Sales by Body Style</h3>
                        <div id="pie-chart"></div>
                    </div>
                    <div class="chart-container">
                        <h3 class="chart-title"> Sales by Income & Gender</h3>
                        <div id="stacked-bar-chart"></div>
                    </div>
                </div>

                <!-- Second Row: 2 charts -->
                <div class="charts-grid" style="grid-template-columns: 1fr 1fr;">
                    <div class="chart-container">
                        <h3 class="chart-title"> Regional Sales Distribution</h3>
                        <div id="regional-map-chart"></div>
                    </div>
                    <div class="chart-container">
                        <h3 class="chart-title"> Top Models by Company</h3>
                        <div id="bar-chart"></div>
                    </div>

                </div>

            </div>
        </div>
    </div>

    <div class="tooltip" id="tooltip"></div>

    <script>
        // Global variables
        let rawData = [];
        let filteredData = [];
        let currentFilters = {
            year: 'all',
            gender: 'all',
            transmission: 'all',
            company: 'all'
        };

        const toggleBtn = document.getElementById('toggleSidebar');
        const sidebar = document.querySelector('.filter-overlay');

        toggleBtn.addEventListener('click', () => {
            sidebar.classList.toggle('hidden');
        });

        // Load and parse CSV data
        async function loadData() {
            try {
                const data = await d3.csv('car_sales.csv', d => ({
                    Car_id: d.Car_id,
                    Date: d.Date,
                    Customer_Name: d['Customer Name'],
                    Gender: d.Gender,
                    Annual_Income: +d['Annual Income'],
                    Dealer_Name: d.Dealer_Name,
                    Company: d.Company,
                    Model: d.Model,
                    Engine: d.Engine,
                    Transmission: d.Transmission,
                    Color: d.Color,
                    Price: +d['Price ($)'],
                    Dealer_No: d.Dealer_No,
                    Body_Style: d['Body Style'],
                    Phone: d.Phone,
                    Dealer_Region: d.Dealer_Region
                }));

                rawData = data;
                filteredData = [...rawData];
                console.log('Data loaded successfully:', rawData.length, 'records');
                init();
            } catch (error) {
                console.error('Error loading CSV file, using sample data:', error);
                rawData = generateSampleData();
                filteredData = [...rawData];
                console.log('Sample data generated:', rawData.length, 'records');
                init();
            }
        }

        // Initialize dashboard
        function init() {
            populateFilters();
            setupEventListeners();
            updateDashboard();
        }

        // Populate filter dropdowns and company logos
        function populateFilters() {
            const years = [...new Set(rawData.map(d => new Date(d.Date).getFullYear()))].sort();
            const yearSelect = d3.select('#year-filter');
            years.forEach(year => {
                yearSelect.append('option').attr('value', year).text(year);
            });

            const companies = [...new Set(rawData.map(d => d.Company))].sort();
            const companyContainer = d3.select('#company-filters');
            companies.forEach(company => {
                companyContainer.append('label')
                    .html(`<input type="checkbox" class="company-filter" value="${company}" checked> ${company}`);
            });


        }

        // Event listeners for filters and company logos
        function setupEventListeners() {
            d3.selectAll('#year-filter, #gender-filter, #transmission-filter').on('change', () => {
                currentFilters.year = d3.select('#year-filter').property('value');
                currentFilters.gender = d3.select('#gender-filter').property('value');
                currentFilters.transmission = d3.select('#transmission-filter').property('value');
                applyFilters();
            });

            // Company checkbox filters
            d3.selectAll('.company-filter').on('change', () => {
                applyFilters();
            });

            d3.select('#reset-filters').on('click', function () {
                // Reset all filters to 'all'
                currentFilters = {
                    year: 'all',
                    gender: 'all',
                    transmission: 'all',
                    company: 'all'
                };

                // Reset dropdown values
                d3.select('#year-filter').property('value', 'all');
                d3.select('#gender-filter').property('value', 'all');
                d3.select('#transmission-filter').property('value', 'all');

                // Reset checkboxes
                document.querySelectorAll('.company-filter').forEach(cb => cb.checked = true);

                // Apply filters (which will reset to show all data)
                applyFilters();
            });
        }

        // Apply filters to the dataset
        function applyFilters() {
            const selectedCompanies = Array.from(document.querySelectorAll('.company-filter:checked')).map(cb => cb.value);
            filteredData = rawData.filter(d => {
                const yearMatch = currentFilters.year === 'all' || new Date(d.Date).getFullYear().toString() === currentFilters.year;
                const genderMatch = currentFilters.gender === 'all' || d.Gender === currentFilters.gender;
                const transmissionMatch = currentFilters.transmission === 'all' || d.Transmission === currentFilters.transmission;
                const companyMatch = selectedCompanies.includes(d.Company);
                return yearMatch && genderMatch && transmissionMatch && companyMatch;
            });

            updateDashboard();
        }

        // Time Series Chart
        function updateTimeSeriesChart() {
            const container = d3.select('#time-series-chart');
            container.selectAll('*').remove();

            if (filteredData.length === 0) return;

            const margin = { top: 20, right: 30, bottom: 40, left: 60 };
            const width = 600 - margin.left - margin.right;
            const height = 300 - margin.bottom - margin.top;

            const svg = container.append('svg')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom);

            const g = svg.append('g')
                .attr('transform', `translate(${margin.left}, ${margin.top})`);

            // Group data by month
            const monthlyData = d3.rollup(filteredData,
                v => ({ count: v.length, revenue: d3.sum(v, d => d.Price) }),
                d => d3.timeMonth(new Date(d.Date))
            );

            const data = Array.from(monthlyData, ([date, values]) => ({
                date: date,
                count: values.count,
                revenue: values.revenue
            })).sort((a, b) => a.date - b.date);

            const x = d3.scaleTime()
                .domain(d3.extent(data, d => d.date))
                .range([0, width]);

            const y = d3.scaleLinear()
                .domain([0, d3.max(data, d => d.count)])
                .range([height, 0]);

            const line = d3.line()
                .x(d => x(d.date))
                .y(d => y(d.count))
                .curve(d3.curveMonotoneX);

            g.append('g')
                .attr('class', 'axis')
                .attr('transform', `translate(0, ${height})`)
                .call(d3.axisBottom(x).tickFormat(d3.timeFormat('%b %Y')));

            g.append('g')
                .attr('class', 'axis')
                .call(d3.axisLeft(y));

            const path = g.append('path')
                .datum(data)
                .attr('class', 'line')
                .attr('d', line)
                .attr("stroke-dasharray", function () {
                    const length = this.getTotalLength();
                    return `${length} ${length}`;
                })
                .attr("stroke-dashoffset", function () {
                    return this.getTotalLength();
                })
                .transition()
                .duration(2500)
                .ease(d3.easeCubicInOut)
                .attr("stroke-dashoffset", 0);

            g.selectAll('.dot')
                .data(data)
                .enter().append('circle')
                .attr('class', 'dot')
                .attr('cx', d => x(d.date))
                .attr('cy', d => y(d.count))
                .attr('r', 4)
                .on('mouseover', function (event, d) {
                    const tooltip = d3.select('#tooltip');
                    tooltip.style('opacity', 1)
                        .html(`<strong>${d3.timeFormat('%B %Y')(d.date)}</strong><br/>
                               Sales: ${d.count}<br/>
                               Revenue: $${d.revenue.toLocaleString()}`)
                        .style('left', (event.pageX + 10) + 'px')
                        .style('top', (event.pageY - 10) + 'px');
                })
                .on('mouseout', function () {
                    d3.select('#tooltip').style('opacity', 0);
                });
        }

        // Pie Chart
        function updatePieChart() {
            const container = d3.select('#pie-chart');
            const width = 250;
            const height = 250;
            const radius = Math.min(width, height) / 2;

            let svg = container.select('svg');
            if (svg.empty()) {
                svg = container.append('svg')
                    .attr('width', width)
                    .attr('height', height);
                svg.append('g')
                    .attr('transform', `translate(${width / 2}, ${height / 2})`)
                    .attr('class', 'pie-group')
                    .style('opacity', 0)  // start hidden
                    .transition()
                    .duration(1500)
                    .style('opacity', 1);  // fade in
            }

            const g = svg.select('.pie-group');

            if (filteredData.length === 0) {
                g.selectAll('path').remove();
                g.selectAll('text').remove();
                return;
            }

            const bodyStyleCounts = d3.rollup(filteredData, v => v.length, d => d.Body_Style);
            const data = Array.from(bodyStyleCounts, ([label, value]) => ({ label, value }));

            const blueColors = [
                '#42a5f5',  // Medium Light Blue
                '#64b5f6',  // Light Blue
                '#90caf9',  // Lighter Blue
                '#bbdefb',  // Very Light Blue
                '#e3f2fd'
            ];
            const color = d3.scaleOrdinal(blueColors);
            const pie = d3.pie().value(d => d.value).sort(null);
            const arc = d3.arc().outerRadius(radius - 10).innerRadius(0);
            const labelArc = d3.arc().outerRadius(radius - 40).innerRadius(radius - 40);
            const tooltip = d3.select('#tooltip');

            const arcs = g.selectAll('path')
                .data(pie(data), d => d.data.label);

            arcs.join(
                enter => enter.append('path')
                    .attr('fill', (d, i) => color(i))
                    .attr('d', arc)
                    .on('mouseover', function (event, d) {
                        tooltip.style('opacity', 1)
                            .html(`<strong>${d.data.label}</strong><br/>
                                             Count: ${d.data.value}<br/>
                                             Percentage: ${((d.data.value / filteredData.length) * 100).toFixed(1)}%`)
                            .style('left', (event.pageX + 10) + 'px')
                            .style('top', (event.pageY - 10) + 'px');
                    })
                    .on('mouseout', () => tooltip.style('opacity', 0)),
                update => update.transition().duration(800).attr('d', arc),
                exit => exit.remove()
            );

            const texts = g.selectAll('text')
                .data(pie(data), d => d.data.label);

            texts.join(
                enter => enter.append('text')
                    .attr('transform', d => `translate(${labelArc.centroid(d)})`)
                    .attr('dy', '.35em')
                    .style('text-anchor', 'middle')
                    .style('font-size', '12px')
                    .text(d => d.data.value > 5 ? d.data.label : ''),
                update => update.transition().duration(800)
                    .attr('transform', d => `translate(${labelArc.centroid(d)})`)
                    .text(d => d.data.value > 5 ? d.data.label : ''),
                exit => exit.remove()
            );

        }

        // Bar Chart
        function updateBarChart() {
            const container = d3.select('#bar-chart');
            container.select('svg').remove(); // only remove this chart's SVG (avoid breaking other DOM elements)

            if (filteredData.length === 0) return;

            const margin = { top: 20, right: 120, bottom: 40, left: 80 };
            const width = 650 - margin.left - margin.right;
            const height = 450 - margin.top - margin.bottom;

            const svg = container.append('svg')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom);

            const g = svg.append('g')
                .attr('transform', `translate(${margin.left}, ${margin.top})`);

            // Group data by company and model
            const companyModelData = d3.rollup(filteredData,
                v => v.length,
                d => d.Company,
                d => d.Model
            );

            // Prepare data for stacking
            const companies = Array.from(companyModelData.keys()).slice(0, 8); // Limit to top 8 companies
            const allModels = new Set();

            // Collect all unique models
            companies.forEach(company => {
                const models = companyModelData.get(company);
                models.forEach((count, model) => allModels.add(model));
            });

            const modelArray = Array.from(allModels);

            // Create data structure for stacking
            const data = companies.map(company => {
                const obj = { company };
                const companyModels = companyModelData.get(company);

                modelArray.forEach(model => {
                    obj[model] = companyModels.get(model) || 0;
                });

                return obj;
            });

            // Sort companies by total sales
            data.sort((a, b) => {
                const totalA = modelArray.reduce((sum, model) => sum + (a[model] || 0), 0);
                const totalB = modelArray.reduce((sum, model) => sum + (b[model] || 0), 0);
                return totalB - totalA;
            });

            // Get top models for each company (limit to top 5 models per company for clarity)
            const topModelsPerCompany = new Map();
            data.forEach(d => {
                const modelCounts = modelArray.map(model => ({ model, count: d[model] }))
                    .filter(m => m.count > 0)
                    .sort((a, b) => b.count - a.count)
                    .slice(0, 5);
                topModelsPerCompany.set(d.company, modelCounts.map(m => m.model));
            });

            // Filter to only include top models
            const relevantModels = new Set();
            topModelsPerCompany.forEach(models => models.forEach(model => relevantModels.add(model)));
            const filteredModels = Array.from(relevantModels);

            // Update data to only include relevant models
            const finalData = data.map(d => {
                const obj = { company: d.company };
                filteredModels.forEach(model => {
                    obj[model] = d[model] || 0;
                });
                return obj;
            });

            // Scales
            const y = d3.scaleBand()
                .domain(data.map(d => d.company))
                .range([0, height])
                .padding(0.2);

            const maxTotal = d3.max(finalData, d =>
                filteredModels.reduce((sum, model) => sum + (d[model] || 0), 0)
            );

            const x = d3.scaleLinear()
                .domain([0, maxTotal])
                .range([0, width]);

            // Color scale
            const color = d3.scaleOrdinal()
                .domain(filteredModels)
                .range(d3.schemeSet3);

            // Stack generator
            const stack = d3.stack()
                .keys(filteredModels);

            const stackedData = stack(finalData);

            // Add axes
            g.append('g')
                .attr('class', 'axis')
                .attr('transform', `translate(0, ${height})`)
                .call(d3.axisBottom(x));

            g.append('g')
                .attr('class', 'axis')
                .call(d3.axisLeft(y));

            const tooltip = d3.select('#tooltip');

            // Create stacked bars
            const layers = g.selectAll('.layer')
                .data(stackedData)
                .enter().append('g')
                .attr('class', 'layer')
                .style('fill', d => color(d.key));


            layers.selectAll('rect')
                .data(d => d)
                .enter().append('rect')
                .attr('y', d => y(d.data.company))
                .attr('x', x(0))
                .attr('width', 0)
                .attr('height', y.bandwidth())
                .style('cursor', 'pointer')
                .transition()
                .duration(1000)
                .attr('x', d => x(d[0]))
                .attr('width', d => x(d[1]) - x(d[0]));

            layers.selectAll('rect')
                .on('mouseover', function (event, d) {
                    const model = d3.select(this.parentNode).datum().key;
                    const value = d[1] - d[0];

                    if (value > 0) {
                        tooltip.style('opacity', 1)
                            .html(`<strong>${d.data.company}</strong><br/>
                        Model: ${model}<br/>
                        Sales: ${value}`)
                            .style('left', (event.pageX + 10) + 'px')
                            .style('top', (event.pageY - 10) + 'px');
                    }
                })
                .on('mouseout', () => tooltip.style('opacity', 0));

            // Legend
            const legend = g.selectAll('.legend')
                .data(filteredModels.slice(0, 10)) // Limit legend items for space
                .enter().append('g')
                .attr('class', 'legend')
                .attr('transform', (d, i) => `translate(${width + 20}, ${i * 15})`);

            legend.append('rect')
                .attr('width', 12)
                .attr('height', 12)
                .style('fill', color);

            legend.append('text')
                .attr('x', 16)
                .attr('y', 6)
                .attr('dy', '.35em')
                .style('text-anchor', 'start')
                .style('font-size', '10px')
                .text(d => d.length > 12 ? d.substring(0, 12) + '...' : d);
        }

        // Stacked Bar Chart
        function updateStackedBarChart() {
            const container = d3.select('#stacked-bar-chart');

            // ONLY remove SVG and legend from this chart
            container.select('svg').remove();
            container.select('.legend-container').remove();

            if (filteredData.length === 0) return;

            const margin = { top: 20, right: 100, bottom: 40, left: 80 };
            const width = 350 - margin.left - margin.right;
            const height = 300 - margin.top - margin.bottom;

            const svg = container.append('svg')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom);

            const g = svg.append('g')
                .attr('transform', `translate(${margin.left}, ${margin.top})`);

            const genders = ['Male', 'Female'];

            const incomeData = filteredData.map(d => ({
                ...d,
                incomeGroup: d.Annual_Income < 40000 ? 'Low (< $40k)' :
                    d.Annual_Income < 80000 ? 'Medium ($40k-$80k)' : 'High (> $80k)'
            }));

            const grouped = d3.rollup(incomeData,
                v => d3.rollup(v, vv => vv.length, d => d.Gender),
                d => d.incomeGroup
            );

            const incomeGroups = Array.from(grouped.keys());

            const data = incomeGroups.map(income => {
                const obj = { income, total: 0 };
                genders.forEach(gender => {
                    const val = grouped.get(income)?.get(gender) || 0;
                    obj[gender] = val;
                    obj.total += val;
                });
                return obj;
            });

            const x = d3.scaleBand()
                .domain(incomeGroups)
                .range([0, width])
                .padding(0.1);

            const y = d3.scaleLinear()
                .domain([0, d3.max(data, d => d.total)])
                .range([height, 0]);

            const color = d3.scaleOrdinal()
                .domain(genders)
                .range(['#64b5f6', '#b62727']);

            const stack = d3.stack().keys(genders);
            const stackedData = stack(data);

            g.append('g')
                .attr('class', 'axis')
                .attr('transform', `translate(0, ${height})`)
                .call(d3.axisBottom(x));

            g.append('g')
                .attr('class', 'axis')
                .call(d3.axisLeft(y));

            const tooltip = d3.select('#tooltip');

            const layers = g.selectAll('.layer')
                .data(stackedData)
                .join('g')
                .attr('class', 'layer')
                .style('fill', d => color(d.key));

            layers.selectAll('rect')
                .data(d => d.map(item => ({ ...item, key: d.key })), d => d.key)
                .join('rect')
                .attr('x', d => x(d.data.income))
                .attr('width', x.bandwidth())
                .attr('y', y(0)) // Start from bottom
                .attr('height', 0) // Zero height
                .transition()
                .duration(800)
                .attr('y', d => y(d[1]))
                .attr('height', d => y(d[0]) - y(d[1]));

            // Attach tooltip separately
            layers.selectAll('rect')
                .on('mouseover', function (event, d) {
                    const value = d[1] - d[0];
                    const percent = ((value / d.data.total) * 100).toFixed(1);
                    tooltip.style('opacity', 1)
                        .html(`<strong>${d.key}</strong><br>Count: ${value}<br>Percentage: ${percent}%`)
                        .style('left', (event.pageX + 10) + 'px')
                        .style('top', (event.pageY - 10) + 'px');
                })
                .on('mouseout', () => tooltip.style('opacity', 0));

            // SVG-based Legend on right side
            const legend = g.selectAll('.legend')
                .data(genders)
                .enter().append('g')
                .attr('class', 'legend')
                .attr('transform', (d, i) => `translate(${width + 20}, ${i * 20})`);

            legend.append('rect')
                .attr('width', 18)
                .attr('height', 18)
                .style('fill', d => color(d));

            legend.append('text')
                .attr('x', 24)
                .attr('y', 9)
                .attr('dy', '.35em')
                .style('text-anchor', 'start')
                .style('font-size', '12px')
                .text(d => d);

            genders.forEach(gender => {
                legend.append('div')
                    .html(`<span style="display:inline-block;width:14px;height:14px;background:${color(gender)};margin-right:6px;border-radius:2px;"></span>${gender}`);
            });
        }


        // Regional Sales Distribution - Real Geographic Choropleth Map
        function updateRegionalMapWithRealGeography() {
            const container = d3.select('#regional-map-chart');
            container.selectAll('*').remove();

            if (filteredData.length === 0) {
                container.append('div')
                    .style('text-align', 'center')
                    .style('padding', '50px')
                    .style('color', '#666')
                    .text('No data available for the selected filters');
                return;
            }

            const width = 600;
            const height = 500;

            const svg = container.append('svg')
                .attr('width', width)
                .attr('height', height);

            // Group data by region (city)
            const regionData = d3.rollup(filteredData,
                v => ({
                    count: v.length,
                    revenue: d3.sum(v, d => d.Price),
                    avgPrice: d3.mean(v, d => d.Price)
                }),
                d => d.Dealer_Region ? d.Dealer_Region.toLowerCase() : 'unknown'
            );

            // Define city coordinates and state information
            const cityCoordinates = {
                'middletown': { lat: 41.5623, lon: -74.4265, state: 'New York', fullName: 'Middletown' },
                'aurora': { lat: 39.7294, lon: -104.8319, state: 'Colorado', fullName: 'Aurora' },
                'greenville': { lat: 34.8526, lon: -82.3940, state: 'South Carolina', fullName: 'Greenville' },
                'pasco': { lat: 46.2396, lon: -119.1006, state: 'Washington', fullName: 'Pasco' },
                'janesville': { lat: 42.6828, lon: -89.0187, state: 'Wisconsin', fullName: 'Janesville' },
                'scottsdale': { lat: 33.4942, lon: -111.9261, state: 'Arizona', fullName: 'Scottsdale' },
                'austin': { lat: 30.2672, lon: -97.7431, state: 'Texas', fullName: 'Austin' }
            };

            // Create state-level data aggregation
            const stateData = new Map();
            Object.entries(cityCoordinates).forEach(([cityKey, cityInfo]) => {
                const cityStats = regionData.get(cityKey);
                if (cityStats) {
                    const currentStateData = stateData.get(cityInfo.state) || { count: 0, revenue: 0, cities: [] };
                    currentStateData.count += cityStats.count;
                    currentStateData.revenue += cityStats.revenue;
                    currentStateData.cities.push({ city: cityInfo.fullName, ...cityStats });
                    stateData.set(cityInfo.state, currentStateData);
                }
            });

            // Create projection for US map
            const projection = d3.geoAlbersUsa()
                .scale(800)
                .translate([width / 2, height / 2]);

            const path = d3.geoPath().projection(projection);

            // Color scale based on sales count
            const maxStateCount = d3.max(Array.from(stateData.values()), d => d.count) || 1;
            const maxCityCount = d3.max(Array.from(regionData.values()), d => d.count) || 1;

            const stateColorScale = d3.scaleSequential(d3.interpolateBlues)
                .domain([0, maxStateCount]);

            const cityColorScale = d3.scaleSequential(d3.interpolateReds)
                .domain([0, maxCityCount]);

            const sizeScale = d3.scaleLinear()
                .domain([0, maxCityCount])
                .range([4, 20]);

            // Load US TopoJSON data from CDN
            const topoJsonUrl = 'https://cdn.jsdelivr.net/npm/us-atlas@3/states-10m.json';

            // Try to load TopoJSON, fallback to simplified version if failed
            d3.json(topoJsonUrl)
                .then(us => {
                    // Convert TopoJSON to GeoJSON
                    const states = topojson.feature(us, us.objects.states);
                    const nation = topojson.feature(us, us.objects.nation);

                    // Create a map of state names to data
                    const stateNameMap = {
                        'Alabama': 'Alabama', 'Alaska': 'Alaska', 'Arizona': 'Arizona', 'Arkansas': 'Arkansas',
                        'California': 'California', 'Colorado': 'Colorado', 'Connecticut': 'Connecticut',
                        'Delaware': 'Delaware', 'Florida': 'Florida', 'Georgia': 'Georgia', 'Hawaii': 'Hawaii',
                        'Idaho': 'Idaho', 'Illinois': 'Illinois', 'Indiana': 'Indiana', 'Iowa': 'Iowa',
                        'Kansas': 'Kansas', 'Kentucky': 'Kentucky', 'Louisiana': 'Louisiana', 'Maine': 'Maine',
                        'Maryland': 'Maryland', 'Massachusetts': 'Massachusetts', 'Michigan': 'Michigan',
                        'Minnesota': 'Minnesota', 'Mississippi': 'Mississippi', 'Missouri': 'Missouri',
                        'Montana': 'Montana', 'Nebraska': 'Nebraska', 'Nevada': 'Nevada', 'New Hampshire': 'New Hampshire',
                        'New Jersey': 'New Jersey', 'New Mexico': 'New Mexico', 'New York': 'New York',
                        'North Carolina': 'North Carolina', 'North Dakota': 'North Dakota', 'Ohio': 'Ohio',
                        'Oklahoma': 'Oklahoma', 'Oregon': 'Oregon', 'Pennsylvania': 'Pennsylvania',
                        'Rhode Island': 'Rhode Island', 'South Carolina': 'South Carolina', 'South Dakota': 'South Dakota',
                        'Tennessee': 'Tennessee', 'Texas': 'Texas', 'Utah': 'Utah', 'Vermont': 'Vermont',
                        'Virginia': 'Virginia', 'Washington': 'Washington', 'West Virginia': 'West Virginia',
                        'Wisconsin': 'Wisconsin', 'Wyoming': 'Wyoming'
                    };

                    // Draw nation boundary
                    svg.selectAll('.nation')
                        .data(nation.features)
                        .enter().append('path')
                        .attr('class', 'nation')
                        .attr('d', path)
                        .attr('fill', '#f8f9fa')
                        .attr('stroke', '#dee2e6')
                        .attr('stroke-width', 1);

                    // Draw state boundaries with choropleth coloring
                    svg.selectAll('.state')
                        .data(states.features)
                        .enter().append('path')
                        .attr('class', 'state')
                        .attr('d', path)
                        .attr('fill', d => {
                            // Try to match state by properties that might exist
                            const stateName = d.properties.name || d.properties.NAME || d.properties.NAME_EN;
                            const stateStats = stateData.get(stateName);
                            return stateStats ? stateColorScale(stateStats.count) : '#f0f0f0';
                        })
                        .attr('stroke', '#fff')
                        .attr('stroke-width', 1)
                        .style('cursor', 'pointer')
                        .on('mouseover', function (event, d) {
                            const stateName = d.properties.name || d.properties.NAME || d.properties.NAME_EN;
                            const stateStats = stateData.get(stateName);

                            d3.select(this)
                                .attr('stroke', '#333')
                                .attr('stroke-width', 2);

                            if (stateStats) {
                                const tooltip = d3.select('#tooltip');
                                const citiesInfo = stateStats.cities
                                    .map(city => `${city.city}: ${city.count} sales`)
                                    .join('<br/>');

                                tooltip.style('opacity', 1)
                                    .html(`<strong>${stateName}</strong><br/>
                                        Total Sales: ${stateStats.count.toLocaleString()}<br/>
                                        Total Revenue: $${stateStats.revenue.toLocaleString()}<br/>
                                        <br/><strong>Cities:</strong><br/>
                                        ${citiesInfo}`)
                                    .style('left', (event.pageX + 10) + 'px')
                                    .style('top', (event.pageY - 10) + 'px');
                            }
                        })
                        .on('mouseout', function () {
                            d3.select(this)
                                .attr('stroke', '#fff')
                                .attr('stroke-width', 1);
                            d3.select('#tooltip').style('opacity', 0);
                        });

                    // Add city points
                    Object.entries(cityCoordinates).forEach(([cityKey, cityInfo]) => {
                        const cityData = regionData.get(cityKey);
                        if (cityData && cityData.count > 0) {
                            const coords = projection([cityInfo.lon, cityInfo.lat]);
                            if (coords) {
                                const [x, y] = coords;

                                // City circle
                                svg.append('circle')
                                    .attr('cx', x)
                                    .attr('cy', y)
                                    .attr('r', sizeScale(cityData.count))
                                    .attr('fill', cityColorScale(cityData.count))
                                    .attr('stroke', '#fff')
                                    .attr('stroke-width', 2)
                                    .attr('opacity', 0.8)
                                    .style('cursor', 'pointer')
                                    .on('mouseover', function (event) {
                                        d3.select(this)
                                            .attr('stroke', '#333')
                                            .attr('stroke-width', 3)
                                            .attr('opacity', 1);

                                        const tooltip = d3.select('#tooltip');
                                        tooltip.style('opacity', 1)
                                            .html(`<strong>${cityInfo.fullName}</strong><br/>
                                                Sales: ${cityData.count.toLocaleString()}<br/>
                                                Revenue: $${cityData.revenue.toLocaleString()}<br/>
                                                Avg Price: $${Math.round(cityData.avgPrice).toLocaleString()}`)
                                            .style('left', (event.pageX + 10) + 'px')
                                            .style('top', (event.pageY - 10) + 'px');
                                    })
                                    .on('mouseout', function () {
                                        d3.select(this)
                                            .attr('stroke', '#fff')
                                            .attr('stroke-width', 2)
                                            .attr('opacity', 0.8);
                                        d3.select('#tooltip').style('opacity', 0);
                                    });

                                // City label
                                svg.append('text')
                                    .attr('x', x)
                                    .attr('y', y - sizeScale(cityData.count) - 5)
                                    .attr('text-anchor', 'middle')
                                    .style('font-size', '10px')
                                    .style('font-weight', 'bold')
                                    .style('fill', '#000000')
                                    .style('pointer-events', 'none')
                                    .text(cityInfo.fullName);
                            }
                        }
                    });

                    // Add legends
                    addMapLegends(svg, width, height, stateColorScale, cityColorScale, maxStateCount, maxCityCount);
                })
                .catch(error => {
                    console.warn('Could not load TopoJSON data, using fallback visualization:', error);
                    // Fallback to your current simplified version
                    createFallbackMap(svg, width, height, regionData, cityCoordinates, sizeScale, cityColorScale, maxCityCount);
                });
        }

        function addMapLegends(svg, width, height, stateColorScale, cityColorScale, maxStateCount, maxCityCount) {
            // State choropleth legend
            const stateLegend = svg.append('g')
                .attr('transform', `translate(50, ${height - 120})`);

            stateLegend.append('text')
                .attr('x', 0)
                .attr('y', 0)
                .style('font-weight', 'bold')
                .style('font-size', '12px')
                .style('fill', '#2c3e50')
                .text('State Sales Volume');

            const stateGradient = svg.append('defs')
                .append('linearGradient')
                .attr('id', 'state-legend-gradient');

            stateGradient.selectAll('stop')
                .data(d3.range(0, 1.1, 0.1))
                .enter().append('stop')
                .attr('offset', d => `${d * 100}%`)
                .attr('stop-color', d => stateColorScale(d * maxStateCount));

            stateLegend.append('rect')
                .attr('x', 0)
                .attr('y', 10)
                .attr('width', 120)
                .attr('height', 12)
                .style('fill', 'url(#state-legend-gradient)')
                .attr('stroke', '#ccc');

            stateLegend.append('text')
                .attr('x', 0)
                .attr('y', 35)
                .style('font-size', '10px')
                .style('fill', '#666')
                .text('0');

            stateLegend.append('text')
                .attr('x', 120)
                .attr('y', 35)
                .attr('text-anchor', 'end')
                .style('font-size', '10px')
                .style('fill', '#666')
                .text(maxStateCount);

            // City legend
            const cityLegend = svg.append('g')
                .attr('transform', `translate(${width - 200}, ${height - 120})`);

            cityLegend.append('text')
                .attr('x', 0)
                .attr('y', 0)
                .style('font-weight', 'bold')
                .style('font-size', '12px')
                .style('fill', '#2c3e50')
                .text('City Sales (Circles)');

            const cityGradient = svg.append('defs')
                .append('linearGradient')
                .attr('id', 'city-legend-gradient');

            cityGradient.selectAll('stop')
                .data(d3.range(0, 1.1, 0.1))
                .enter().append('stop')
                .attr('offset', d => `${d * 100}%`)
                .attr('stop-color', d => cityColorScale(d * maxCityCount));

            cityLegend.append('rect')
                .attr('x', 0)
                .attr('y', 10)
                .attr('width', 120)
                .attr('height', 12)
                .style('fill', 'url(#city-legend-gradient)')
                .attr('stroke', '#ccc');

            cityLegend.append('text')
                .attr('x', 0)
                .attr('y', 35)
                .style('font-size', '10px')
                .style('fill', '#666')
                .text('0');

            cityLegend.append('text')
                .attr('x', 120)
                .attr('y', 35)
                .attr('text-anchor', 'end')
                .style('font-size', '10px')
                .style('fill', '#666')
                .text(maxCityCount);

            cityLegend.append('text')
                .attr('x', 0)
                .attr('y', 55)
                .style('font-size', '10px')
                .style('fill', '#666')
                .text('Circle size = city sales count');
        }

        function createFallbackMap(svg, width, height, regionData, cityCoordinates, sizeScale, colorScale, maxCount) {
            // Fallback simplified map (your current implementation)
            svg.append('rect')
                .attr('width', width)
                .attr('height', height)
                .attr('fill', '#f0f8ff')
                .attr('stroke', '#ccc')
                .attr('stroke-width', 1);

            svg.append('text')
                .attr('x', width / 2)
                .attr('y', 30)
                .attr('text-anchor', 'middle')
                .style('font-size', '16px')
                .style('font-weight', 'bold')
                .style('fill', '#2c3e50')
                .text('Regional Sales Distribution (Simplified View)');

            // Continue with your existing simplified visualization...
            // (keeping your current fallback code here)
        }



        // Update KPIs and charts
        function updateDashboard() {
            // Update KPIs
            const totalCars = filteredData.length;
            const totalRevenue = d3.sum(filteredData, d => d.Price);
            const avgPrice = totalCars > 0 ? totalRevenue / totalCars : 0;
            const avgCustomerIncome = totalCars > 0 ? d3.mean(filteredData, d => d.Annual_Income) : 0;

            d3.select('#total-cars').text(totalCars.toLocaleString());
            d3.select('#total-revenue').text(`$${totalRevenue.toLocaleString()}`);
            d3.select('#avg-price').text(`$${Math.round(avgPrice).toLocaleString()}`);
            d3.select('#avg-customer-income').text(`$${Math.round(avgCustomerIncome).toLocaleString()}`);

            // Update all charts
            updateTimeSeriesChart();
            updatePieChart();
            updateBarChart();
            updateStackedBarChart();
            updateRegionalMapWithRealGeography();
        }

        // Load data on page load
        loadData();
    </script>
</body>

</html>